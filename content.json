[{"title":"[问题]Windows环境下nssm注册的mysql服务无法启动","date":"2023-12-15T01:30:00.000Z","path":"2023/12/15/question-mysqld-service.html","text":"环境手上有个项目上一直使用的一键安装包，包括了上位机、后端、前端、数据库、时序库、nginx等一系列东西。一直都是通过 nssm 将这些软件注册成自启动服务的。注册的方式大概是这样： install.bat:: 注册mysql nssm-2.24\\win64\\nssm install xxx-scada-mysql %cd%\\mysql-8.0.27-winx64\\bin\\mysqld.exe nssm-2.24\\win64\\nssm set xxx-scada-mysql AppDirectory %cd%\\mysql-8.0.27-winx64\\bin :: 启动mysql nssm-2.24\\win64\\nssm start xxx-scada-mysql 前两天我们需要在公司的一台测试服务器上安装这套项目软件，先检查了公司的服务器环境，发现已经有了 mysql 和 nginx 服务，于是手动停止这两个服务，之后使用一键安装包部署项目。 此时，系统中有一个之前已经安装的 mysql，称为 数据库A。数据库A 通过 mysqld install 命令安装了服务，称为 服务A， 服务A 已经被手动停止运行。一键安装包中又拷贝了一份 mysql 进去，称为 数据库B。通过 nssm 安装的 数据库B 服务称为 服务B。 问题过程 发现通过 nssm 注册的 服务B 无法启动，所以关闭 服务B。 手动运行 数据库B 中的 mysqld 程序，发现程序闪退，没有报错信息，也没有错误日志。 怀疑是依赖问题，尝试了更新 MSVC ，没有效果。 尝试使用 数据库B 中的 mysqld --log-error=my.err ，发现 mysqld 不再闪退，但是此时依然不能正常提供数据库服务，并且没有异常的错误日志。 同事启动了 服务A ，发现可以正常使用。 受同事启发，尝试删除 服务A，此时脑袋混乱，居然是使用 数据库B 执行的 mysqld --remove，没想到依然能删除 服务A。 发现删除 服务A 后，数据库B 中的 mysqld 可以正常使用了，再次尝试 服务B ，发现也可以正常使用。 思考本次问题的出现，主要原因还是我对 Windows 系统不熟悉，对于 Windows 系统中服务注册原理完全不懂。 长期使用 nssm 进行服务管理，让我们可以一直忽略 Windows 的服务管理细节，不断地向前走下去。同时也让我们失去了探索 Windows 服务管理的动力。其实，假如世界上没有 nssm ，也许需要一周，也许需要一两个月，我们总是能学会注册服务的方法。 因为工具过于方便导致失去了底层能力，这次的问题只是这个道理的再一次体现而已。","tags":[{"name":"项目实践","slug":"项目实践","permalink":"https://vitsumoc.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"},{"name":"问题","slug":"问题","permalink":"https://vitsumoc.github.io/tags/%E9%97%AE%E9%A2%98/"},{"name":"Windows","slug":"Windows","permalink":"https://vitsumoc.github.io/tags/Windows/"}]},{"title":"[翻译]Sol - 从零开始的MQTT broker - 第一部分：协议","date":"2023-12-08T07:30:15.000Z","path":"2023/12/08/translate-sol-1.html","text":"原文 Sol - An MQTT broker from scratch. Part 1 - The protocol 前言我已经在物联网领域工作有一段时间了，这段时间里我一直在处理物联网架构相关的工作，探索物联网系统开发的最佳模式，研究相关的协议和标准，例如MQTT。 因为我一直在渴望着提升我编程能力的机会，我觉得在物联网方向深入研究会很有趣也很有好处。因此，我再一次 git init 了一个项目，并且要通过写下这些博客来挑战我自己，强迫自己进步。 Sol 是一个C语言项目，一个超级简单的Linux平台的MQTT broker，支持MQTT 3.3.1，不兼容旧的版本，非常类似于轻量级的 Mosquitto （虽然这玩意已经是个轻量级软件了）。由于现在有很多种类的MQTT客户端，所以测试起来会比较简单。最终的成品可能会成为一个更简洁，功能更丰富的软件，我们要创造这个功能的最小化实现。顺便提一下，Sol 这个名字的来源有一半的原因是我对短名称的偏好，另一半的原因则是火星日 (The Martian docet)。或者说，Sol 可能代表Scrappy Ol’ Loser。emmmm 注意：这个项目一直到最后才会编译，你需要跟写所有的代码步骤。如果你想要在中途进行测试，我建议你自己建一个主函数来做这些测试或者修改。 一步一步来，我一般会创建一个这样的文件结构来初始化我的C项目： sol&#x2F; ├── src&#x2F; ├── CHANGELOG ├── CMakeLists.txt ├── COPYING └── README.md 这里是Github上的仓库。 我会尝试着一步一步描述 Sol 的开发过程，但我也不会贴上所有的代码，只会解释关键的地方。你想要学习的最好方式依然是亲自编写、编译、修改代码。 这将是一系列文章，每篇文章都将讨论并主要实施项目的一个概念&#x2F;模块： 第一部分 ： 协议 MQTT协议数据包处理的基础 第二部分 ： 网络 解决网络通讯的功能模块 第三部分 ： 服务 程序入口 第四部分 ： 数据结构 实用和实验性的模块 第五部分 ： Topic abstraction broker的主要功能 第六部分 ： Handlers 完成服务，对每个数据包都有处理 特别篇 ： 多线程 多线程模型的改进、错误修复和集成 我想说，虽然 sol 会是一个完全功能的 broker，但仍有很大改进和优化空间，以及可能的一些隐藏功能（俗称BUG）。 架构设计broker 的本质是一个中间件，它接受来自多个客户端（生产者）的输入，并使用抽象方法将其转发给一组目标客户端（消费者），这种抽象方法用于定义和管理这些客户端组，形式为 channel 或 topic（根据协议标准）。与 IRC 频道或通用聊天中的等效概念非常相似，每个消费者客户端都可以订阅 topic，以便接收其他客户端发布到这些 topic 的所有消息。 第一个想到的是建立在某种数据结构之上的服务器，这种数据结构可以轻松管理这些 topic 和连接的客户端（无论是生产者还是消费者）。客户端收到的每个消息都必须转发给所有订阅了该消息指定 topic 的其他已连接客户端。 让我们试试这种方法，使用一个 TCP 服务器和一个用于处理数据流的模块。实现服务器的方法有很多，包括线程、fork 进程和多路 I&#x2F;O，这次我将尝试用多路 I&#x2F;O 的方式。 我们先使用单线程多路 I&#x2F;O 服务器，未来有可能进行多线程拓展。实际上，用于多路复用的 epoll 接口是线程安全的。 MQTT结构首先，我们需要基于官方文档，制作一些描述 MQTT 协议数据包的结构体。 从 opcode 表和 MQTT 头开始，基于文档，每个数据包都包含以下三部分： fixed header（必选） variable header（可选） payload（可选） Fixed HeaderFixed Header的第一个字节包括了 MQTT type 和 Flags，第二到第五个字节使用可变编码的方式，存储剩余数据包的长度。 Fixed Header | Bit | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | |--------|---------------|---------------| | Byte 1 | MQTT type | Flags | |--------|-------------------------------| | Byte 2 | | | . | Remaining Length | | . | | | Byte 5 | | Flags并不是强制填写的，只是一些控制类数据，内容如下： Dup flag： 当消息被发送超过一次时使用 QoS level： 有以下三种取值 AT_MOST_ONCE&#x3D;0， AT_LEAST_ONCE&#x3D;1 and EXACTLY_ONCE&#x3D;2 Retain flag： 保留标志，有保留标志的消息被发布到主题时，消息会被保留，之后连接进来的客户端也可以收到该消息。保留消息可以被另一条保留消息覆盖。 所以，打开 Vim （或者其他任何你喜欢的IDE），创建名为 mqtt.h 的头文件，开始写关于 Fixed Header 的数据结构吧： src/mqtt.h#ifndef MQTT_H #define MQTT_H #include &lt;stdio.h> #define MQTT_HEADER_LEN 2 #define MQTT_ACK_LEN 4 /* * 回复信息枚举，用于 Fixed Header 中的第一个字节 * 准确的说是只负责设置高位的4bit */ #define CONNACK_BYTE 0x20 #define PUBLISH_BYTE 0x30 #define PUBACK_BYTE 0x40 #define PUBREC_BYTE 0x50 #define PUBREL_BYTE 0x60 #define PUBCOMP_BYTE 0x70 #define SUBACK_BYTE 0x90 #define UNSUBACK_BYTE 0xB0 #define PINGRESP_BYTE 0xD0 /* 信息类型 */ enum packet_type &#123; CONNECT = 1, CONNACK = 2, PUBLISH = 3, PUBACK = 4, PUBREC = 5, PUBREL = 6, PUBCOMP = 7, SUBSCRIBE = 8, SUBACK = 9, UNSUBSCRIBE = 10, UNSUBACK = 11, PINGREQ = 12, PINGRESP = 13, DISCONNECT = 14 &#125;; enum qos_level &#123; AT_MOST_ONCE, AT_LEAST_ONCE, EXACTLY_ONCE &#125;; union mqtt_header &#123; unsigned char byte; // 将 header 视为一个byte操作 struct &#123; // 将 header 视为内部结构分开操作 unsigned retain : 1; // 保留标识 unsigned qos : 2; // qos标识 unsigned dup : 1; // 重复标识 unsigned type : 4; // 4bit Flags &#125; bits; &#125;; 最上方的两个 #define 定义了 MQTT Fixed Header 和 MQTT ACK 的长度。 正如你在代码中看到的，我们利用了 union——一种可以在内存中的同一位置存储多种表示形式的结构——来表示一个字节。换句话说，与普通的 struct 不同，union 中只能有一个字段具有值（在此例中是byte或bits）。它们的内存位置是共享的，因此，通过使用位字段，我们可以有效地操作单个比特或字节的一部分。 CONNECT我们要定义的第一个控制数据包是 CONNECT。 这是当客户端建立新连接时必须发送的第一个数据包，CONNECT 包必须是有且仅有一个，否则视为与协议不符，服务端需要断开连接。 对于每个 CONNECT，服务端需要在响应中回复 CONNACK。 src/mqtt.hstruct mqtt_connect &#123; union mqtt_header header; // 第一个byte是通用头 union &#123; // 第二个byte表示一些控制信息 unsigned char byte; struct &#123; int reserved : 1; unsigned clean_session : 1; // 为1时表示新session，否则表示已有session unsigned will : 1; // 表示是否有遗嘱 unsigned will_qos : 2; // 表示遗嘱的QOS unsigned will_retain : 1; // 表示遗嘱发布时是否保留 unsigned password : 1; // 表示是否有密码 unsigned username : 1; // 表示是否有用户名 &#125; bits; &#125;; struct &#123; // 载荷 unsigned short keepalive; // 会话保活时间，单位秒 unsigned char *client_id; unsigned char *username; unsigned char *password; unsigned char *will_topic; unsigned char *will_message; &#125; payload; &#125;; struct mqtt_connack &#123; union mqtt_header header; union &#123; unsigned char byte; struct &#123; unsigned session_present : 1; unsigned reserved : 7; &#125; bits; &#125;; unsigned char rc; &#125;; 按照这个模式，结合 MQTT v3.1.1 的文档，其他数据包的定义也比较简单了。 SUBSCRIBE UNSUBSCRIBE PUBLISH ACK等接下来我们处理 SUBSCRIBE，UNSUBSCRIBE 和 PUBLISH。SUBSCRIBE 必须要使用 SUBACK 来响应，其他的都可以使用通用 ACK，并设置 typedef 字段的值来响应。 src/mqtt.hstruct mqtt_subscribe &#123; union mqtt_header header; unsigned short pkt_id; unsigned short tuples_len; // 接下来数据元组的长度 struct &#123; unsigned short topic_len; // 接下来 topic 字符串的长度 unsigned char *topic; unsigned qos; &#125; *tuples; &#125;; struct mqtt_unsubscribe &#123; union mqtt_header header; unsigned short pkt_id; unsigned short tuples_len; struct &#123; unsigned short topic_len; unsigned char *topic; &#125; *tuples; &#125;; struct mqtt_suback &#123; // 针对 SUB 动作的响应 union mqtt_header header; unsigned short pkt_id; unsigned short rcslen; unsigned char *rcs; &#125;; struct mqtt_publish &#123; // 发布消息 union mqtt_header header; unsigned short pkt_id; unsigned short topiclen; unsigned char *topic; unsigned short payloadlen; unsigned char *payload; &#125;; struct mqtt_ack &#123; // 通用响应 union mqtt_header header; unsigned short pkt_id; &#125;; 剩余的这一类ACK包： PUBACK PUBREC PUBREL PUBCOMP UNSUBACK PINGREQ PINGRESP DISCONNECT 因为有相同的结构，所以都可以通过 typedef 来定义，只是语义有所不同。最后一个 DISCONNECT，虽然严格来说不是一个 ACK，但是也有相同的结构。 src/mqtt.htypedef struct mqtt_ack mqtt_puback; typedef struct mqtt_ack mqtt_pubrec; typedef struct mqtt_ack mqtt_pubrel; typedef struct mqtt_ack mqtt_pubcomp; typedef struct mqtt_ack mqtt_unsuback; typedef union mqtt_header mqtt_pingreq; typedef union mqtt_header mqtt_pingresp; typedef union mqtt_header mqtt_disconnect; MQTT最终我们可以定义一个通用 MQTT 包，包括上面的一切，后续我们所有的 MQTT 数据包都可以用这个结构来表示。 src/mqtt.hunion mqtt_packet &#123; struct mqtt_ack ack; // 通用ACK union mqtt_header header; // 通用头 struct mqtt_connect connect; // CONNECT包 (这种包里会包括一个通用头) struct mqtt_connack connack; // CONNACK包 struct mqtt_suback suback; // SUBBACK包 struct mqtt_publish publish; // PUBLISH包 struct mqtt_subscribe subscribe; // SUB包 struct mqtt_unsubscribe unsubscribe; // UNSUB包 &#125;; MQTT函数编码解码现在我们继续定义一些公共函数。在 src/mqtt.h 中，我们需要考虑其他模块使用 MQTT 协议时会用到哪些函数。 为了使用 MQTT 协议处理通信，我们基本上需要 4 个函数，其中客户端向服务端有 2 个，服务端向客户端也是 2 个： 一个编码函数（总之就是把内存里的数据做成二进制流，这里不讨论术语） 一个解码函数（就是从二进制流恢复成内存结构） 我们还需要 2 个函数来处理 fixed head 部分中变长的 Remaining Length 字段。 src/mqtt.h// 编码时生成 Remaining Length int mqtt_encode_length(unsigned char *, size_t); // size_t 指uint32 或 uint64 // 解码时解析 Remaining Length unsigned long long mqtt_decode_length(const unsigned char **); // 将char * 解码为 mqtt_packet * int unpack_mqtt_packet(const unsigned char *, union mqtt_packet *); // 将 mqtt_packet * 编码为 char * unsigned char *pack_mqtt_packet(const union mqtt_packet *, unsigned); // unsigned指 unsigned int 内存操作我们还需要一些工具函数，用来进行基于数据包的内存分配、释放，这里没啥特别的。 src/mqtt.h// 申请内存，制作各种MQTT包 union mqtt_header *mqtt_packet_header(unsigned char); struct mqtt_ack *mqtt_packet_ack(unsigned char , unsigned short); struct mqtt_connack *mqtt_packet_connack(unsigned char , unsigned char , unsigned char); struct mqtt_suback *mqtt_packet_suback(unsigned char, unsigned short, unsigned char *, unsigned short); struct mqtt_publish *mqtt_packet_publish(unsigned char, unsigned short, size_t, unsigned char *, size_t, unsigned char *); // 释放MQTT包 void mqtt_packet_release(union mqtt_packet *, unsigned); 函数实现MQTT包编解码接口好了，我们现在有一个不错的头文件了，定义了我们通讯协议中的所有内容，现在我们需要实现这些函数了。为了能够实现这些功能，首先我们要定义几个私有的帮助函数，用来进行编码和解码的动作。这些函数会被公有函数unpack_mqtt_packet 和 pack_mqtt_packet 调用。 src/mqtt.c#include &lt;stdlib.h> #include &lt;string.h> #include \"mqtt.h\" // 一系列对于具体类型包的 pack unpack 函数 static size_t unpack_mqtt_connect(const unsigned char *, union mqtt_header *, union mqtt_packet *); static size_t unpack_mqtt_publish(const unsigned char *, union mqtt_header *, union mqtt_packet *); static size_t unpack_mqtt_subscribe(const unsigned char *, union mqtt_header *, union mqtt_packet *); static size_t unpack_mqtt_unsubscribe(const unsigned char *, union mqtt_header *, union mqtt_packet *); static size_t unpack_mqtt_ack(const unsigned char *, union mqtt_header *, union mqtt_packet *); static unsigned char *pack_mqtt_header(const union mqtt_header *); static unsigned char *pack_mqtt_ack(const union mqtt_packet *); static unsigned char *pack_mqtt_connack(const union mqtt_packet *); static unsigned char *pack_mqtt_suback(const union mqtt_packet *); static unsigned char *pack_mqtt_publish(const union mqtt_packet *); 二进制流编解码实现在继续实现 src/mqtt.h 上所有定义的函数之前，我们需要实现一些辅助函数，以简化每个接收到的数据包的编码解码过程。 让我们快速搞定这部分，这一块只是简单的序列化和反序列化操作而已（记得用Big-endian就行）。 src/pack.h#ifndef PACK_H #define PACK_H #include &lt;stdio.h> #include &lt;stdint.h> /* 从数据流中获得数据的方法 */ // bytes -> uint8_t uint8_t unpack_u8(const uint8_t **); // bytes -> uint16_t uint16_t unpack_u16(const uint8_t **); // bytes -> uint32_t uint32_t unpack_u32(const uint8_t **); // 读取定义的 len 个字节（用来读取字符串） uint8_t *unpack_bytes(const uint8_t **, size_t, uint8_t *); // 读取字符串前面的 ushort 长度，并申请 dest内存块存字符串 uint16_t unpack_string16(uint8_t **buf, uint8_t **dest) /* 将数据写入数据流的方法 */ // append a uint8_t -> bytes into the bytestring void pack_u8(uint8_t **, uint8_t); // append a uint16_t -> bytes into the bytestring void pack_u16(uint8_t **, uint16_t); // append a uint32_t -> bytes into the bytestring void pack_u32(uint8_t **, uint32_t); // 将 len 个字节追加到bytes中 void pack_bytes(uint8_t **, uint8_t *); #endif 以及相应的实现 src/pack.c#include &lt;string.h> #include &lt;stdlib.h> #include &lt;arpa/inet.h> #include \"pack.h\" // Reading data uint8_t unpack_u8(const uint8_t **buf) &#123; uint8_t val = **buf; (*buf)++; return val; &#125; uint16_t unpack_u16(const uint8_t **buf) &#123; uint16_t val; memcpy(&amp;val, *buf, sizeof(uint16_t)); (*buf) += sizeof(uint16_t); return ntohs(val); &#125; uint32_t unpack_u32(const uint8_t **buf) &#123; uint32_t val; memcpy(&amp;val, *buf, sizeof(uint32_t)); (*buf) += sizeof(uint32_t); return ntohl(val); &#125; uint8_t *unpack_bytes(const uint8_t **buf, size_t len, uint8_t *str) &#123; memcpy(str, *buf, len); str[len] = '\\0'; (*buf) += len; return str; &#125; uint16_t unpack_string16(uint8_t **buf, uint8_t **dest) &#123; uint16_t len = unpack_u16(buf); *dest = malloc(len + 1); *dest = unpack_bytes(buf, len, *dest); return len; &#125; // Write data void pack_u8(uint8_t **buf, uint8_t val) &#123; **buf = val; (*buf) += sizeof(uint8_t); &#125; void pack_u16(uint8_t **buf, uint16_t val) &#123; uint16_t htonsval = htons(val); memcpy(*buf, &amp;htonsval, sizeof(uint16_t)); (*buf) += sizeof(uint16_t); &#125; void pack_u32(uint8_t **buf, uint32_t val) &#123; uint32_t htonlval = htonl(val); memcpy(*buf, &amp;htonlval, sizeof(uint32_t)); (*buf) += sizeof(uint32_t); &#125; void pack_bytes(uint8_t **buf, uint8_t *str) &#123; size_t len = strlen((char *) str); memcpy(*buf, str, len); (*buf) += len; &#125; 这样我们就完成了字节流和数据类型的双向转换工作。 Remaining Length编解码实现完成了 pack 部分后，我们需要把他们运用在我们的MQTT包里，首先当然是： src/mqtt.c#include \"pack.h\" 第一步我们可以实现对 Fixed Header 中的 Remaining Length 字段的操作。MQTT文档中提供了这一段实现的伪代码，我们可以仿写一下。 让我们来看看 Remaining Length 如何用1-4个变长的Byte来表示剩余包的长度。 Remaining Length 表示的是数据包剩余部分的长度，包括 variable header 和 payload。Remaining Length 中表示的长度不包括 Remaining Length 字段本身所占用的长度。 Remaining Length 的编码使用了一种可变长度编码方案，该方案对 127 以下的值使用单个字节。较大的值则按以下方式处理：每个字节的低 7 位编码数据，高位用于指示是否存在后续字节。因此，每个字节编码 128 个值和一个 “延续位”。Remaining Length 字段的最大字节数为 4。 MQTT的文档已经描述的非常清晰，我们只需要实现。 src/mqtt.c/* * 基于 MQTT v3.1.1，Fixed Header 中的 Remaining Length 最大为4byte */ static const int MAX_LEN_BYTES = 4; /* * 根据数据包长度制作变长的 Remaining Length * return Remaining Length 的字节长度 * buf Remaining Length 的数据流 * len Remaining Length 应该表示的值（可变头+载荷总长度） */ int mqtt_encode_length(unsigned char *buf, size_t len) &#123; // 字节长度 int bytes = 0; do &#123; if (bytes + 1 > MAX_LEN_BYTES) return bytes; short d = len % 128; len /= 128; // len > 0 表示还有后续位 if (len > 0) d |= 128; // 标记最高位 buf[bytes++] = d; &#125; while (len > 0); return bytes; &#125; /* * 解析数据流中的 Remaing Length 并将指针移动到下一个位置 * return Remaining Length 的值 * buf Remaining Length 的数据流 * * TODO Handle case where multiplier > 128 * 128 * 128 */ unsigned long long mqtt_decode_length(const unsigned char **buf) &#123; char c; // 乘数 int multiplier = 1; // 值 unsigned long long value = 0LL; do &#123; c = **buf; value += (c &amp; 127) * multiplier; multiplier *= 128; // 后移一位 (*buf)++; // 当没有后续位标识时结束 &#125; while ((c &amp; 128) != 0); return value; &#125; CONNECT 解码实现好了，现在我们可以完整的解析 Fixed Header 了，接下来我们试着解码 CONNECT 包。 CONNECT 是一个有很多flags的包，而且长度仅次于 PUBLISH 包。 CONNECT 包的内容包括： Fixed Header 中的 MQTT type + Flags，高4位（MQTT type）（称为MSB）的值是1，表示Connect type，低4位（Flags）（LSB）保留 Fixed Header 中的变长 Remaining Length，表示剩余部分的长度 Variable Header，由四个字段组成： Protocol Name Protocol Level Connect Flags Keep Alive 可能存在或者不存在的 payload（基于 Connect Flags 的设置） Protocol Name 是 UTF-8 编码的大写字符串 “MQTT”，这个字段的长度和内容在未来版本的MQTT协议中都不会再改变。 所以 3.1.1 版本的 Protocol Name 就是 “MQTT”，我们也不用去管旧版本的名字是什么了。 Connect flags 为一个byte，包含了一些关于客户端行为以及是否有 payload 段存在的标识： Connect flags 中的字段 大小 含义 Username flag 1bit 表示用户名存在与否 Password flag 1bit 表示密码存在与否 Will retain 1bit 表示遗嘱是否保留 Will QoS 2bit 表示遗嘱的QOS等级 Will flag 1bit 表示遗嘱存在与否 Clean Session 1bit 表示是否为新链接 Connect flags的最高位保留，其他所有位都被当作bool值初始化（除了Will QoS），这些bool值在 payload 部分也有相应的字段。比如当 Username 和 Password 的值为1，那么在 payload 中会有 2byte 的 username length，紧随其后的就是 username 字符串，Password也是相同的道理。 为了说明这件事，假设我们收到了这样一个 CONNECT 包： Connect flags 中的 username 和 password 都置为1 username &#x3D; “hello” password &#x3D; “nacho” client ID &#x3D; “danzan” 那么这个数据包应该长这样： 字段 大小 偏移量 描述 Packet type + Falgs 1 0 类型为Connect type 0x01，Flags为空 Length 1 1 后续总长度32Byte，小于127，所以可以用1Byte表示 Protocol name length 2 2 协议名长度，值固定为 0x04 Protocol name 4 4 ‘M’ ‘Q’ ‘T’ ‘T’ Protocol level 1 8 对于MQTT 3.1.1 此字段值为 0x04 Connect flags 1 9 包括 Username, password, will retain, will QoS, will flag, clean session Keepalive 2 10 ushort，保活时间，单位秒，最大值65536（18小时12分15秒） Client ID length 2 12 ushort, 此例中值为0x06 (danzan) Client ID 6 14 ‘d’ ‘a’ ‘n’ ‘z’ ‘a’ ‘n’ Username length 2 20 ushort, 此例中值为0x05 (hello) Username 5 22 ‘h’ ‘e’ ‘l’ ‘l’ ‘o’ Password length 2 27 ushort, 此例中值为0x05 (nacho) Password 5 29 ‘n’ ‘a’ ‘c’ ‘h’ ‘o’ 例如因为 Will Flags 被置为0，所以我们不需要在 payload 中解析这个字段（也压根没有），上例中我们要解析的内容总共就是包括 Fixed Header 在内的 34个byte。 src/mqtt.c/* * CONNECT 解码函数 * return Remaing Length 的值 * buf 数据流，从变长长度开始 * hdr 已经解码好的头部 * pkt 返回的解码后数据包 */ static size_t unpack_mqtt_connect(const unsigned char *buf, union mqtt_header *hdr, union mqtt_packet *pkt) &#123; // 制作一个connect结构体，并且用已经解码好的头部赋值 // 此处有一个已经解码好的头部，是因为数据作为二进制流进来的时候，肯定是要先解码出头部，然后再根据包类型分到不同的函数里做进一步解码的 struct mqtt_connect connect = &#123; .header = *hdr &#125;; // 将这个结构体赋值到pkt pkt->connect = connect; // 初始指针指向buf的首部 const unsigned char *init = buf; /* * 获得后续的变长总长度,同时将指针移动到 protocol name */ size_t len = mqtt_decode_length(&amp;buf); // 暂时忽略协议名称、保留字段等等，所以直接向后移动8byte // 这里 init 直接+8，暗示了变长长度字段的长度是1byte，所以才能+8后指向Connect flags buf = init + 8; // 读取 Connect flags pkt->connect.byte = unpack_u8((const uint8_t **) &amp;buf); // 读取 keepalive pkt->connect.payload.keepalive = unpack_u16((const uint8_t **) &amp;buf); // 读取 CID 长度（如果有CID则>0，否则为0） uint16_t cid_len = unpack_u16((const uint8_t **) &amp;buf); // 如果有，则读取CID if (cid_len > 0) &#123; pkt->connect.payload.client_id = malloc(cid_len + 1); unpack_bytes((const uint8_t **) &amp;buf, cid_len, pkt->connect.payload.client_id); &#125; // 如果有，则读取遗嘱 if (pkt->connect.bits.will == 1) &#123; unpack_string16(&amp;buf, &amp;pkt->connect.payload.will_topic); unpack_string16(&amp;buf, &amp;pkt->connect.payload.will_message); &#125; // 如果有，则读取用户名 if (pkt->connect.bits.username == 1) unpack_string16(&amp;buf, &amp;pkt->connect.payload.username); // 如果有，则读取密码 if (pkt->connect.bits.password == 1) unpack_string16(&amp;buf, &amp;pkt->connect.payload.password); return len; &#125; PUBLISH 解码实现以下是 PUBLISH 包的结构： | Bit | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | &lt;-- Fixed Header |----------|-----------------------|--------------------------| | Byte 1 | MQTT type 3 | dup | QoS | retain | |----------|--------------------------------------------------| | Byte 2 | | | . | Remaining Length | | . | | | Byte 5 | | |----------|--------------------------------------------------| &lt;-- Variable Header | Byte 6 | Topic len MSB | | Byte 7 | Topic len LSB | |-------------------------------------------------------------| | Byte 8 | | | . | Topic name | | Byte N | | |----------|--------------------------------------------------| | Byte N+1 | Packet Identifier MSB | | Byte N+2 | Packet Identifier LSB | |----------|--------------------------------------------------| &lt;-- Payload | Byte N+3 | Payload | | Byte N+M | | 仅当 QoS level &gt; 0 时，存在 Packet identifier MSB 和 LSB。当 QoS 被设置为 at most once （值为0）时，没有必要存在 packet ID。 Payload部分的长度通过 Remaining Length 减去其他所有内容计算得来。 src/mqtt.c/* * PUBLISH 解码函数 * return Remaing Length 的值 * buf 数据流，从变长长度开始 * hdr 已经解码好的头部 * pkt 返回的解码后数据包 */ static size_t unpack_mqtt_publish(const unsigned char *buf, union mqtt_header *hdr, union mqtt_packet *pkt) &#123; // 创建 PUBLISH 包并且使用已经解码好的 header 赋值 struct mqtt_publish publish = &#123; .header = *hdr &#125;; // 准备给返回值提供这个 PUBLISH 包 pkt->publish = publish; // 通过变长的 Remaing Length 字段获取剩余部分的长度 size_t len = mqtt_decode_length(&amp;buf); // 获得 topiclen 和 topic 内容 pkt->publish.topiclen = unpack_string16(&amp;buf, &amp;pkt->publish.topic); // 将 len 赋值, 并视为 payload 长度 uint16_t message_len = len; // 如果 QoS > 0, 需要读取pkt_id if (publish.header.bits.qos > AT_MOST_ONCE) &#123; pkt->publish.pkt_id = unpack_u16((const uint8_t **) &amp;buf); // 此时payload长度需要减去pkt_id message_len -= sizeof(uint16_t); &#125; // payload 长度需要减去 topic_len 字段长度和 topic 字段实际长度 message_len -= (sizeof(uint16_t) + topic_len); // 这里是正确的 payloadlen pkt->publish.payloadlen = message_len; // 读取 payload pkt->publish.payload = malloc(message_len + 1); unpack_bytes((const uint8_t **) &amp;buf, message_len, pkt->publish.payload); return len; &#125; SUBSCRIBE 和 UNSUBSCRIBE 解码实现SUBSCRIBE 包和 UNSUBSCRIBE 包的结构非常相似。他们的 payload 部分都是一个 topic 相关的元组列表，其中 SUBSCRIBE 的元组是 (topic_len, topic_filter, qos)，而 UNSUBSCRIBE 是 (topic_len, topic_filter)。 src/mqtt.c/* * SUBSCRIBE 解码函数 * return Remaing Length 的值 * buf 数据流，从变长长度开始 * hdr 已经解码好的头部 * pkt 返回的解码后数据包 */ static size_t unpack_mqtt_subscribe(const unsigned char *buf, union mqtt_header *hdr, union mqtt_packet *pkt) &#123; // 创建 SUBSCRIBE 包并且使用已经解码好的 header 赋值 struct mqtt_subscribe subscribe = &#123; .header = *hdr &#125;; // 通过变长的 Remaing Length 字段获取剩余部分的长度 size_t len = mqtt_decode_length(&amp;buf); size_t remaining_bytes = len; // 读取pkt_id subscribe.pkt_id = unpack_u16((const uint8_t **) &amp;buf); remaining_bytes -= sizeof(uint16_t); /* * 订阅频道列表, 由一系列三元组构成 * - topic length 主题字符串长度 * - topic filter (string) 主题filter * - qos */ int i = 0; while (remaining_bytes > 0) &#123; // 减去2byte, 是topic length的空间 remaining_bytes -= sizeof(uint16_t); // 给这个主题字符串分配内存 subscribe.tuples = realloc(subscribe.tuples, (i+1) * sizeof(*subscribe.tuples)); // 获得主题字符串长度, 获得主题字符串内容 subscribe.tuples[i].topic_len = unpack_string16(&amp;buf, &amp;subscribe.tuples[i].topic); // 减去主题字符串实际占用的空间 remaining_bytes -= subscribe.tuples[i].topic_len; // 获得主题qos subscribe.tuples[i].qos = unpack_u8((const uint8_t **) &amp;buf); // 减去主题 qos 的空间 len -= sizeof(uint8_t); // 操作下一个主题 i++; &#125; // 记录订阅主题数 subscribe.tuples_len = i; // 记录到 mqtt_packet pkt->subscribe = subscribe; return len; &#125; /* * UNSUBSCRIBE 解码函数 * return Remaing Length 的值 * buf 数据流，从变长长度开始 * hdr 已经解码好的头部 * pkt 返回的解码后数据包 */ static size_t unpack_mqtt_unsubscribe(const unsigned char *buf, union mqtt_header *hdr, union mqtt_packet *pkt) &#123; struct mqtt_unsubscribe unsubscribe = &#123; .header = *hdr &#125;; /* * Second byte of the fixed header, contains the length of remaining bytes * of the connect packet */ size_t len = mqtt_decode_length(&amp;buf); size_t remaining_bytes = len; /* Read packet id */ unsubscribe.pkt_id = unpack_u16((const uint8_t **) &amp;buf); remaining_bytes -= sizeof(uint16_t); /* * Read in a loop all remaining bytes specified by len of the Fixed Header. * From now on the payload consists of 2-tuples formed by: * - topic length * - topic filter (string) */ int i = 0; while (remaining_bytes > 0) &#123; /* Read length bytes of the first topic filter */ remaining_bytes -= sizeof(uint16_t); /* We have to make room for additional incoming tuples */ unsubscribe.tuples = realloc(unsubscribe.tuples, (i+1) * sizeof(*unsubscribe.tuples)); unsubscribe.tuples[i].topic_len = unpack_string16(&amp;buf, &amp;unsubscribe.tuples[i].topic); remaining_bytes -= unsubscribe.tuples[i].topic_len; i++; &#125; unsubscribe.tuples_len = i; pkt->unsubscribe = unsubscribe; return len; &#125; ACK 解码实现最终到了 ACK 包，MQTT 协议中没有设计通用 ACK，但是实际上每个 ACK 包的数据结构都是一样的，有一个 Fixed Header 和一个 packet_id组成。 MQTT 协议中有如下几种类型的ACK: PUBACK PUBREC PUBREL PUBCOMP UNSUBACK src/mqtt.c/* * ACK 解码函数 * return Remaing Length 的值 * buf 数据流，从变长长度开始 * hdr 已经解码好的头部 * pkt 返回的解码后数据包 */ static size_t unpack_mqtt_ack(const unsigned char *buf, union mqtt_header *hdr, union mqtt_packet *pkt) &#123; // 创建 ACK 包并且使用已经解码好的 header 赋值 struct mqtt_ack ack = &#123; .header = *hdr &#125;; // 通过变长的 Remaing Length 字段获取剩余部分的长度 size_t len = mqtt_decode_length(&amp;buf); // pkt_id ack.pkt_id = unpack_u16((const uint8_t **) &amp;buf); pkt->ack = ack; return len; &#125; MQTT包解码实现现在我们已经实现了 unpack_mqtt_packet 需要的所有工具函数，接下来我们先定义一个解码函数的接口，然后使用一个静态数组来索引所有的解码函数，这里我们直接使用 Control Packet type 的值来作为数组中的索引。 需要注意的是，DISCONNECT PINGREQ PINGRESP 这三种包只有一个byte，所以我们不需要编写解码工具函数。 src/mqtt.c// 解码函数接口 typedef size_t mqtt_unpack_handler(const unsigned char *, union mqtt_header *, union mqtt_packet *); // 所有解码函数的列表, 索引值和包类型对应 static mqtt_unpack_handler *unpack_handlers[11] = &#123; NULL, unpack_mqtt_connect, NULL, unpack_mqtt_publish, unpack_mqtt_ack, unpack_mqtt_ack, unpack_mqtt_ack, unpack_mqtt_ack, unpack_mqtt_subscribe, NULL, unpack_mqtt_unsubscribe &#125;; // MQTT 包解码入口 int unpack_mqtt_packet(const unsigned char *buf, union mqtt_packet *pkt) &#123; int rc = 0; // 第一个 byte 是 fiexd header 中的 mqttType + flags unsigned char type = *buf; // 第一个byte可以被作为header union mqtt_header header = &#123; .byte = type &#125;; // 对于这些包暂时无需解码 if (header.bits.type == DISCONNECT || header.bits.type == PINGREQ || header.bits.type == PINGRESP) pkt->header = header; else // 通过包类型找到解码函数, 执行解码操作后返回rc, 此时rc等于具体解码函数的返回值 rc = unpack_handlers[header.bits.type](++buf, &amp;header, pkt); return rc; &#125; 结尾从零开始MQTT broker的第一部分就这样结束了，我们做了两个模块，一个根据 OASIS 定义的标准描述MQTT协议结构，另一个则用来处理编解码操作。 此时我们的文件结构是这样的： sol&#x2F; ├── src&#x2F; │ ├── mqtt.h │ ├── mqtt.c │ ├── pack.h │ └── pack.c ├── CHANGELOG ├── CMakeLists.txt ├── COPYING └── README.md","tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://vitsumoc.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"翻译","slug":"翻译","permalink":"https://vitsumoc.github.io/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"[翻译] n2n 常见问题","date":"2023-12-07T08:55:07.000Z","path":"2023/12/07/translate-n2n-faq.html","text":"原文 n2n Frequently Asked Questions项目地址 n2n 常见问题 发布哪里能找到Windows系统的n2n软件？我们没有在release中发布Windows版本的n2n，但是我们的自动化测试流程会创建他们。你可以点击项目界面中的 Actions，选择 Testing，进入最近一次的运行实例，在界面最下方的 Artifacts 处下载 binaries，其中就包括了编译好的windows版本n2n。通常来说你可以使用 x86_64-w64-mingw32\\usr\\sbin 路径下的版本。 此外，正如我们的README中提到的，luckytu 一直在更新n2n的Windows版本，你也可以在他那里直接下载编译后的软件。 Supernode我想部署一个私有的，有密码保护的supernode，需要怎么设置？你可以直接配置 community.list 文件，在其中设置一个 &lt;community name&gt; (输入单行文本即可) ，然后把这个 &lt;community name&gt; 当作您的密码。 在启动 supernode 时，记得加上 -c &lt;community file&gt; 参数指定配置文件。这样，只有设置了 -c &lt;community name&gt; 的 edge 可以使用 supernode。 此时，在您的 edge 向 supernode 注册的过程中，&lt;community name&gt; 是明文传递的。如果您想要对传输过程进行加密，需要在所有 edge 节点启动时添加 -H 参数。 另外，请参阅 n2n 附带的 community.list 文件以了解该文件的高级使用。 除了这个访问障碍之外，您可能希望在边缘使用有效负载加密 -A_。 只有边缘（而不是超级节点）能够解密有效负载数据。 因此，即使任何人都能够打破超级节点的访问障碍，有效负载仍然受到有效负载加密的保护，请参阅此文档了解详细信息。 除了上述的这些安全手段之外，您还可以在 edge 添加 -A_ 参数来加密传输的数据。数据的加密和解密都是 edge 进行的，所以即使是 supernode 节点也无法解密数据内容。因此，即使你的 supernode 节点被黑客入侵，你的数据内容依然是被加密算法保护的。更多细节可以参考这一篇关于加密的文档。 我可以在supernode查看接入的edge列表吗？可以，supernode 通过UDP提供了基本的管理接口，默认端口是5645，可以通过 -t 参数修改。 只需要发送一个新的行就可以查询当前状态，例如，在 supernode 本机（远程链接不可以）上按下[ENTER]键，然后输入如下命令： netcat -u localhost 5645 支持多个supernode节点的部署方式吗？支持，这篇文档描述了如何部署多个 supernode 节点来提升网络的可用性。 supernode可以监听多个UDP端口吗？supernode 本身只支持监听一个端口，但是你应该可以通过做NAT的方式将多个端口映射到同一个端口上，例如： sudo iptables -t nat -A PREROUTING -i &lt;network interface name&gt; -d &lt;supernode&#39;s ip address&gt; -p udp --dport &lt;additional port number&gt; -j REDIRECT --to-ports &lt;regular supernode port number&gt; 这条命令可以作为 ExecStartPost= 添加到 supernode 的 .service 文件中（不需要加sudo），如果需要映射多个端口，可以多加几行。 这个报错是怎么回事 “process_udp dropped a packet with seemingly encrypted header for which no matching community which uses encrypted headers was found”？这条报错的意思是 supernode 收到了一个无法使用的数据包。supernode 先将这个包视为一个未加密的包来处理，如果处理失败的话，supernode 会假定这是一个加密的数据包，之后 supernode 会尝试所有可以生成key的 community （排除明确没有加密的community）。如果任何 community 的key都无法解开此数据包，就会产生这条报错。 如果所有 edge 的 -H 参数配置是相同的（都有 -H 或者都没有 -H ），并且重启 supernode 后依然报错，最大的可能是 supernode 或者 edge 的版本不一致，导致了数据包格式不一致。 因此，请确保所有 edge 和 supernode 具有完全相同的版本，例如：最新的 _dev_ 分支。 Edge如何查看p2p链接的状态？edge 同样提供了一个本地的UDP管理端口，包括了 peers 这种已经建立的p2p链接，还有 pending peers 这种通过 supernode 中转的链接。 edge 的默认管理端口号是 5644，可以通过 -t 参数修改。可以在本机通过此命令查看： netcat -u localhost 5644 发送空行就可以查看链接信息，对于其他的命令行功能，请通过 help 查看。 edge 反复报错 “Authentication error. MAC or IP address already in use or not released yet by supernode”。是什么问题？Edge 遇到了 n2n 的防欺骗保护。 它可以防止一个边缘的身份（MAC 和 IP 地址）在原始边缘仍然在线时被其他边缘冒充，请参阅一些详细信息。 大多数情况下，有两种情况可以触发此操作： 这是触发了 n2n 的防欺骗保护机制，这个机制可以防止已经在线的 edge 节点被其他人冒充，这篇文档有更详细的描述。总之，大部分情况下，有两种可能触发这个机制： 你使用的 MAC 地址或 IP 地址已经被使用了，修改这些参数就可以了。 如果一个 edge 非正常退出，例如被 kill -9 ... 或 kill -SIGKILL ...，那么这个 edge 可能没有机会通知 supernode 取消注册，因此 supernode 仍然认为此 edge 在线，此时具有相同 MAC 或 IP 地址的注册就不会成功。 supernode 记录 edge 的超时时间是两分钟，所以可以等待两分钟，或者换不同的 MAC 和 IP 地址注册。 基本上来说，不管是 CTRL + C 或是 kill -SIGTERM ... 或者 kill -SIGINT ... 或者 kill ... 不带9，都可以正常的结束 edge，在管理接口下发 stop 命令也可以停止 edge ，所以大部分情况下无需使用 kill -9 ...。","tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://vitsumoc.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"网络工具","slug":"网络工具","permalink":"https://vitsumoc.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"},{"name":"翻译","slug":"翻译","permalink":"https://vitsumoc.github.io/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"使用n2n连接不同局域网设备","date":"2023-12-06T06:37:00.000Z","path":"2023/12/06/n2nBeginner.html","text":"前言目的是想在办公室使用家里的服务器 家里有不固定的公网IP，办公室有固定的公网IP，因此打算使用办公室服务器做Server 为什么不用frp？：因为想获得一个完整的网络服务，而frp只能做端口映射，如果开发过程中新增端口，需要修改frp就很麻烦 n2n简介n2n 是一个开源项目，地址在这里： https://github.com/ntop/n2n n2n 是一个二层VPN技术，他能在家里的服务器和办公室的服务器之间创建一个局域网链接 n2n 网络由 supernode 和 edge 组成，可以简单理解为同一 supernode 下的所有 edge 都处在同一个局域网中。 网络环境办公室网络： 网段：192.168.34.0&#x2F;24 网关：192.168.34.1 网关公网地址：88.88.88.88 服务器地址：192.168.34.194 家庭网络 网段：192.168.0.0&#x2F;24 网关：192.168.0.1 网关公网地址：不固定 服务器地址：192.168.0.12 规划n2n网络由于办公室有固定的公网地址，就由办公室服务器充当 supernode，同时家庭服务器和办公室服务器都是此 supernode 下的 edgen2n 会形成一个新的局域网，规划如下： 网段：10.0.34.0&#x2F;24 网关：无 办公室服务器：10.0.34.21 家庭服务器：10.0.34.41 实施下载安装n2n在办公室服务器和家庭服务器都下载并安装 n2n： https://github.com/ntop/n2n/releases 安装完成后，服务器中会自动生成两个服务 supernode 和 edge 配置文件位于 /etc/n2n/ 配置办公室服务器办公室服务器需要承担三个职能：充当 supernode，充当 edge，转发其他办公室设备到家庭服务器的网络包 配置supernode配置 /etc/n2n/community.list 文件，指定community名称 community.listcom8888 # community名称 复制 supernode.conf.sample 文件，并修改配置内容 bashcp /etc/n2n/supernode.conf.sample /etc/n2n/supernode.conf bashvi /etc/n2n/supernode.conf supernode.conf-p&#x3D;7777 # 指定supernode服务端口 -c&#x3D;&#x2F;etc&#x2F;n2n&#x2F;community.list # 指定引用的community文件 启动supernode shellsystemctl enable supernode systemctl start supernode 之后可以看到 supernode 已经启动，并且在7777端口提供服务： 配置edge配置 edge 使办公室服务器成为 n2n 网络的成员 复制 edge.conf.sample 文件，并修改配置内容 bashcp /etc/n2n/edge.conf.sample /etc/n2n/edge.conf bashvi /etc/n2n/edge.conf edge.conf-d&#x3D;n2n0 # 指定虚拟网卡名称 -c&#x3D;com8888 # community名称 -k&#x3D;888888 # 通讯加密密钥 -a&#x3D;10.0.34.21 # 在n2n网络中的地址 -l&#x3D;127.0.0.1:7777 # supernode服务地址 -r # 允许通过n2n转发数据包 启动edge shellsystemctl enable edge systemctl start edge 启动后，可以看到 n2n 已经添加了虚拟网卡： 开启数据包转发功能需要通过办公室服务器转发办公室其他电脑到家庭服务器的流量，因此需要在办公室服务器上开启数据包转发功能 需要将 /etc/sysctl.conf 文件中的 net.ipv4.ip_forward 修改为 1 bashvi /etc/sysctl.conf sysctl.conf... net.ipv4.ip_forward&#x3D;1 ... 配置办公室网关添加静态路由其他办公室电脑没有到 n2n 网络的路由，因此数据包会发送到办公室网关 此时需要配置办公室网关，添加一条指向 n2n 网络的静态路由，下一条为办公室服务器的办公网地址 配置家庭服务器配置edge，设置自动添加路由家庭服务器的 edge 安装配置过程与办公室服务器的 edge 大致相同，但有两点需要注意： 无需添加-r参数，因为家庭服务器不需要将来自其他设备的包转发到n2n网络 需要添加-n参数，这样edge启动时会自动产生一条通过n2n网络到达办公室网络的路由 edge.conf-d&#x3D;n2n0 # 指定虚拟网卡名称 -c&#x3D;com8888 # community名称 -k&#x3D;888888 # 通讯加密密钥 -a&#x3D;10.0.34.41 # 在n2n网络中的地址 -l&#x3D;88.88.88.88:17777 # supernode公网地址 -n&#x3D;192.168.34.0&#x2F;24:10.0.34.21 验证n2n网络验证使用 n2n 网络地址从办公室服务器ping家庭服务器，或从家庭服务器ping办公室服务器，成功 此时数据包的实际流向是 办公室服务器-&gt;办公室网关-&gt;运营商网络-&gt;家庭网关-&gt;家庭服务器 由于 n2n vpn的配置，此时可以认为办公室服务器和家庭服务器处在同一局域网下，tracert也仅一跳可达 办公室电脑到家庭服务器网络验证办公室电脑ping家庭服务器，成功 此时数据包流向是 办公室电脑-&gt;办公室网关-&gt;办公室服务器-&gt;家庭服务器，其中办公室服务器到家庭服务器是 n2n 虚拟链路 tracert三跳可达 家庭服务器到办公室电脑家庭服务器ping办公室电脑，成功 此时数据包流向是 家庭服务器-&gt;办公室服务器-&gt;办公室电脑，其中家庭服务器到办公室服务器是 n2n 虚拟链路 tracert两跳可达","tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://vitsumoc.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"网络工具","slug":"网络工具","permalink":"https://vitsumoc.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"}]},{"title":"工作周报可视化","date":"2023-12-05T03:31:51.000Z","path":"2023/12/05/weekreport2chart.html","text":"起因这个项目是一个纯粹的小玩具，起因是我公司的工作周报都是 .doc 格式存储的，现在到年底了，我又比较想知道我一年都干了哪些工作。显而易见的一个方式就是提取所有周报文字内容做词频分析。 效果完成之后的效果还算不错，源码也放在了github上： https://github.com/vitsumoc/weekreport2chart 提取一段时间的工作周报内容，生成词云和河流图 可以直接过滤低频词汇，或手动操作删除某些虚词、连词等 相关库使用libreoffice将doc转为docx 使用结巴分词分词：https://github.com/fxsjy/jieba 使用wordcloudjs词云：https://wordcloud2-js.timdream.org/#love 使用echarts河流图","tags":[{"name":"python","slug":"python","permalink":"https://vitsumoc.github.io/tags/python/"},{"name":"小玩具","slug":"小玩具","permalink":"https://vitsumoc.github.io/tags/%E5%B0%8F%E7%8E%A9%E5%85%B7/"},{"name":"js","slug":"js","permalink":"https://vitsumoc.github.io/tags/js/"}]},{"title":"在golang中使用lua","date":"2023-12-05T03:25:15.000Z","path":"2023/12/05/golua.html","text":"使用gopher-lua，在golang中使用lua。gopher-lua 项目地址： https://github.com/yuin/gopher-lua 使用示例仓库地址： https://github.com/vitsumoc/my-golua 示例列表： 最基础的用法 基础数据类型 在lua中调用go方法 在go中使用lua协程 示范如何手动开启模块 在lua中使用go模块 在golang中调用lua方法 在lua中使用golang数据 通过context控制停止 在有协程的情况下使用context控制 共享lua文件字节码, 减少开销 通过go协程跑lua的示例 可以把ch带到lua中 和相关限制 在lua中使用ch的例子 lua虚拟机池 在golang中提供钩子, 使lua可以注册脚本, 在脚本中获得并修改用户数据","tags":[{"name":"golang","slug":"golang","permalink":"https://vitsumoc.github.io/tags/golang/"},{"name":"库","slug":"库","permalink":"https://vitsumoc.github.io/tags/%E5%BA%93/"},{"name":"小玩具","slug":"小玩具","permalink":"https://vitsumoc.github.io/tags/%E5%B0%8F%E7%8E%A9%E5%85%B7/"}]},{"title":"使用Systemd管理自启动","date":"2023-12-01T06:19:42.000Z","path":"2023/12/01/linuxBoot.html","text":"常用命令启动服务 shellsystemctl start service-name 停止服务 shellsystemctl stop service-name 查看服务状态 shellsystemctl status service-name 设置开机自启动 shellsystemctl enable service-name 停止开机自启动 shellsystemctl disable service-name 服务注册在 /etc/systemd/system 路径下，创建 service-name.service 文件，格式如下： service-name.service[Unit] # 服务名称 Description = xxxx server After = network.target syslog.target Wants = network.target [Service] Type = simple # 启动命令 ExecStart = /home/start.sh [Install] WantedBy = multi-user.target","tags":[{"name":"豆知识","slug":"豆知识","permalink":"https://vitsumoc.github.io/tags/%E8%B1%86%E7%9F%A5%E8%AF%86/"},{"name":"环境配置","slug":"环境配置","permalink":"https://vitsumoc.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Linux","slug":"Linux","permalink":"https://vitsumoc.github.io/tags/Linux/"}]},{"title":"AI入门笔记（3）——感知器","date":"2023-12-01T01:32:11.000Z","path":"2023/12/01/AiForBeginners-3.html","text":"课程https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/3-NeuralNetworks/03-Perceptron/README.md 这是微软提供的AI-For-Beginners课程第三课，介绍了什么是感知器（Perceptron） 内容感知器Perceptron是一种二元分类模型，总是能根据输入产生一个+1或-1的输出。 感知器进行计算时需要权重weight的参与，权重会导致感知器产生正确或错误的结果，训练的过程既是修改权重不断增加结果的正确率。 感知器只能解决线性分类的问题，如果一个问题无法被线性分类，感知器就不会收敛，例如异或问题。 随堂作业在本课的作业中，需要使用 Jupyter 构建代码+文档的环境，使用 sklearn 创造测试数据，使用 numPy 表示和处理数据，使用 matpoltlib 绘制数据图像，使用 ipywidgets 交互式的查看训练过程。 训练感知器分类数据https://github.com/vitsumoc/exercise-AI-Beginner/blob/main/3-Perceptron/perceptron.py 作业中使用代码实现了训练感知器的过程： 创建数据集合，分类为训练数据和测试数据 将训练数据分类为pos和neg 初始化权重值 设置训练次数并开始训练，每次选择随机的数据进行训练 在每次训练错误时，使用本次选择的数据对权重进行调整 使用测试数据验证训练后的权重值 感知器的局限性https://github.com/vitsumoc/exercise-AI-Beginner/blob/main/3-Perceptron/xor.ipynb 感知器只能解决线性分类问题，对于无法使用一条直线分类的问题，往往就无法很好的收敛。 作业中的异或问题就是一个完全无法收敛的例子。 使用感知器 + MNIST 数据识别手写数字https://github.com/vitsumoc/exercise-AI-Beginner/blob/main/3-Perceptron/mnist.ipynb 在这个作业中使用感知器区分手写数字图像。 使用PCA降低特征的维度，分析感知器训练结果差异的原因。 训练感知器识别任何手写数字这个作业中需要拓展上一个作业的功能，训练10个不同的感知器，用来识别0-9全部的数字。 https://github.com/vitsumoc/exercise-AI-Beginner/blob/main/3-Perceptron/anyNum.ipynb 参考上一个作业的方式，训练了10组weights，来判断一个数字是或不是特定的数字。 每个感知器训练10000次，最终正确率 74.7%。","tags":[{"name":"AI","slug":"AI","permalink":"https://vitsumoc.github.io/tags/AI/"},{"name":"笔记","slug":"笔记","permalink":"https://vitsumoc.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Jupyter入门笔记","date":"2023-11-30T06:29:43.000Z","path":"2023/11/30/pythonJupyter.html","text":"前言网站 https://jupyter.org/ jupyter 项目提供了可供计算的记事本，将代码、资源、交互式计算与文档结合。 试用可以通过试用界面 https://jupyter.org/try 直接体验jupyter，建立大致的了解。 打开jupyter lab 在指定路径打开jupyter lab，程序会占用8888端口，可通过http://localhost:8888/访问图形化界面。 文件jupyter会将执行程序的目录作为文件系统的根目录。 jupyter的文件后缀为 .ipynb 其中可以混合代码、文档、输出。 可以直接在 jupyter lab 提供的浏览器界面中新建、编辑、删除文件。 内容编辑以下是一个混合了 文档、代码、输出、图像、组件的文件截图，因为导出的PDF不支持组件，所以组件输出为文本。 github也支持 .ipynb 格式，但同样不支持组件，这是上方图片文件的原始内容： https://github.com/vitsumoc/exercise-AI-Beginner/blob/main/PyBeginner/jupyter.ipynb","tags":[{"name":"豆知识","slug":"豆知识","permalink":"https://vitsumoc.github.io/tags/%E8%B1%86%E7%9F%A5%E8%AF%86/"},{"name":"笔记","slug":"笔记","permalink":"https://vitsumoc.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"python","permalink":"https://vitsumoc.github.io/tags/python/"},{"name":"库","slug":"库","permalink":"https://vitsumoc.github.io/tags/%E5%BA%93/"}]},{"title":"Matplotlib入门笔记","date":"2023-11-29T07:40:57.000Z","path":"2023/11/29/pythonMatplotlib.html","text":"前言网站 https://matplotlib.org/stable/ Matplotlib 是一个用于创建静态、动画和交互式可视化的综合库。 本文是学习 Matplotlib 过程中的笔记，所有内容都来自官方文档：https://matplotlib.org/stable/users/explain/quick_start.html 1. 入门示例pythonimport matplotlib.pyplot as plt import numpy as np import matplotlib as mpl def e1(): x = np.linspace(0, 2 * np.pi, 200) y = np.sin(x) fig, ax = plt.subplots() ax.plot(x, y) plt.show() e1() 2. 窗口、图像和绘制pythondef e2(): # 创建一个只有一个 axes 的 figure fig, ax = plt.subplots() # 在 axes 上 plot 一些数据 ax.plot([1, 2, 3, 4], [1, 4, 2, 3]) plt.show() e2() 3. figure 的构成部分python# figure 是一个绘图窗口 # axes 是一副数据图像 # axis 是坐标轴 def e3(): # 一个没有 axes 的 figure fig = plt.figure() # 只有一个 axes 的图像 fig, ax = plt.subplots() # 2 * 2 布局的图像 fig, axs = plt.subplots(2, 2) # 左一右二布局 fig, axs = plt.subplot_mosaic([['left', 'right_top'], ['left', 'right_bottom']]) plt.show() e3() 4. 输入数据类型pythondef e4(): # plot 接受 np.array np.ma.masked_array np.asarray 三种类型的输入 # 如果不是此类数据，需要先进行处理 b = np.matrix([[1, 2], [3, 4]]) b_asarray = np.asarray(b) # 对于一些已经准备好的对象(字典)数据, 也可以用下面的方式输入 np.random.seed(19680801) # seed the random number generator. # a 是 0-50 的整数 用于每个数据的 x 坐标 # b 是 50个随机数 用于每个数据的 y 坐标 (50个0-1的随机数 * 10 再加 x坐标) # c 随机颜色 50个50以下的整数 # d 是随机尺寸 data = &#123;'a': np.arange(50), 'c': np.random.randint(0, 50, 50), 'd': np.random.randn(50)&#125; data['b'] = data['a'] + 10 * np.random.randn(50) data['d'] = np.abs(data['d']) * 100 fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained') # 离散数据 使用字典中的内容赋值 ax.scatter('a', 'b', c='c', s='d', data=data) ax.set_xlabel('entry a') ax.set_ylabel('entry b') plt.show() e4() 5. 接口风格python# mplib提供了两种接口风格 一是显示的获取各层对象并调用 二是直接使用plt搞定一切 # 显示风格的例子 def e5_1(): x = np.linspace(0, 2, 100) # 示意数据 # 获得 figure 和 axes fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained') # 一次二次和三次函数 ax.plot(x, x, label='linear') ax.plot(x, x**2, label='quadratic') ax.plot(x, x**3, label='cubic') # 指定xy的label ax.set_xlabel('x label') ax.set_ylabel('y label') # axes 的title ax.set_title(\"Simple Plot\") # 添加一个图例 用来显示各plot的label ax.legend() plt.show() # 隐式风格的例子 效果和显示风格完全相同 def e5_2(): x = np.linspace(0, 2, 100) plt.figure(figsize=(5, 2.7), layout='constrained') plt.plot(x, x, label='linear') plt.plot(x, x**2, label='quadratic') plt.plot(x, x**3, label='cubic') plt.xlabel('x label') plt.ylabel('y label') plt.title(\"Simple Plot\") plt.legend() plt.show() e5_1() e5_2() 6. 制作辅助函数python# 制作工具函数, 避免代码重复 def e6_plotter(ax, data1, data2, param_dict): \"\"\" A helper function to make a graph. \"\"\" out = ax.plot(data1, data2, **param_dict) return out def e6(): data1, data2, data3, data4 = np.random.randn(4, 100) # make 4 random data sets fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(5, 2.7)) e6_plotter(ax1, data1, data2, &#123;'marker': 'x'&#125;) e6_plotter(ax2, data3, data4, &#123;'marker': 'o'&#125;) plt.show() e6() 7. 样式pythondef e7(): data1, data2 = np.random.randn(2, 100) fig, ax = plt.subplots(figsize=(5, 2.7)) x = np.arange(len(data1)) # plot 直接跟样式参数 ax.plot(x, np.cumsum(data1), color='blue', linewidth=3, linestyle='--') l, = ax.plot(x, np.cumsum(data2), color='orange', linewidth=2) # plot 后对返回内容进行样式赋值 l.set_linestyle(':') plt.show() e7() 8. 标记基础标记pythondef e8_1(): mu, sigma = 115, 15 # x 是一万个值的列表 randn 会给出一组正态分布的随机数结果 x = mu + sigma * np.random.randn(10000) fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained') # the histogram of the data # 直方图参数: x-数据内容 50-柱数量 density-返回概率密度 n, bins, patches = ax.hist(x, 50, density=True, facecolor='C0', alpha=0.75) # 轴和图的标题 ax.set_xlabel('Length [cm]') ax.set_ylabel('Probability') ax.set_title('Aardvark lengths\\n (not really)') # 文本 (使用了数学符号) ax.text(75, .025, r'$\\mu=115,\\ \\sigma=15$') # 轴定义 ax.axis([55, 175, 0, 0.03]) # 网线 ax.grid(True) plt.show() e8_1() 标记图上的点pythondef e8_2(): fig, ax = plt.subplots(figsize=(5, 2.7)) t = np.arange(0.0, 5.0, 0.01) s = np.cos(2 * np.pi * t) line, = ax.plot(t, s, lw=2) # 使用点位、文本位、箭头设置来标记点 ax.annotate('local max', xy=(2, 1), xytext=(3, 1.5), arrowprops=dict(facecolor='black', shrink=0.05)) # y轴limit ax.set_ylim(-2, 2) plt.show() e8_2() 添加 Legend用以区分数据pythondef e8_3(): data1, data2, data3 = np.random.randn(3, 100) fig, ax = plt.subplots(figsize=(5, 2.7)) ax.plot(np.arange(len(data1)), data1, label='data1') ax.plot(np.arange(len(data2)), data2, label='data2') ax.plot(np.arange(len(data3)), data3, 'd', label='data3') ax.legend() plt.show() e8_3() 9. 轴的比例和刻度轴的比例定义pythondef e9_1(): # 100 个随机数 data1 = np.random.randn(100) # 两个 axes fig, axs = plt.subplots(1, 2, figsize=(5, 2.7), layout='constrained') # x轴为随机数的数量 xdata = np.arange(len(data1)) # y数据为 10 ** data1 data = 10**data1 # axes 使用折线图 axs[0].plot(xdata, data) # axes 使用对数坐标 图像内容接近 data1 的原始值 axs[1].set_yscale('log') axs[1].plot(xdata, data) plt.show() e9_1() 手动操作 axis 上的 tickspythondef e9_2(): data1 = np.random.randn(100) xdata = np.arange(len(data1)) fig, axs = plt.subplots(2, 1, layout='constrained') axs[0].plot(xdata, data1) axs[0].set_title('Automatic ticks') axs[1].plot(xdata, data1) # 设置x 轴和显示内容 axs[1].set_xticks(np.arange(0, 100, 30), ['zero', '30', 'sixty', '90']) # 设置 y 轴 axs[1].set_yticks([-1.5, 0, 1.5]) axs[1].set_title('Manual ticks') plt.show() e9_2() 使用时间做轴pythondef e9_3(): fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained') # 通过时间范围和间隔构建时间戳数组 dates = np.arange(np.datetime64('2021-11-15'), np.datetime64('2021-12-25'), np.timedelta64(1, 'h')) # 随机数的数据 data = np.cumsum(np.random.randn(len(dates))) # x 和 y 数据正常放入图像 ax.plot(dates, data) # 设置日期格式化方式并添加到轴 cdf = mpl.dates.ConciseDateFormatter(ax.xaxis.get_major_locator()) ax.xaxis.set_major_formatter(cdf) plt.show() e9_3() 使用字符串做轴pythondef e9_4(): fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained') categories = ['turnips', 'rutabaga', 'cucumber', 'pumpkins'] ax.bar(categories, np.random.rand(len(categories))) plt.show() e9_4() 添加更多的轴pythondef e9_5(): t = np.arange(0.0, 5.0, 0.01) s = np.cos(2 * np.pi * t) # fig上的图像为 ax1 和 ax3 fig, (ax1, ax3) = plt.subplots(1, 2, figsize=(7, 2.7), layout='constrained') l1, = ax1.plot(t, s) # ax2 和 ax1 绘制在一起, 共享x轴 ax2 = ax1.twinx() l2, = ax2.plot(t, range(len(t)), 'C1') ax2.legend([l1, l2], ['Sine (left)', 'Straight (right)']) ax3.plot(t, s) ax3.set_xlabel('Angle [rad]') # secondary_xaxis 用于创建一个新的x轴 传入了和原x轴的互相转换函数 ax4 = ax3.secondary_xaxis('top', functions=(np.rad2deg, np.deg2rad)) ax4.set_xlabel('Angle [°]') plt.show() e9_5() 10. 色块图pythondef e10(): data1, data2, data3 = np.random.randn(3, 100) X, Y = np.meshgrid(np.linspace(-3, 3, 128), np.linspace(-3, 3, 128)) Z = (1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2) fig, axs = plt.subplots(2, 2, layout='constrained') pc = axs[0, 0].pcolormesh(X, Y, Z, vmin=-1, vmax=1, cmap='RdBu_r') fig.colorbar(pc, ax=axs[0, 0]) axs[0, 0].set_title('pcolormesh()') co = axs[0, 1].contourf(X, Y, Z, levels=np.linspace(-1.25, 1.25, 11)) fig.colorbar(co, ax=axs[0, 1]) axs[0, 1].set_title('contourf()') pc = axs[1, 0].imshow(Z**2 * 100, cmap='plasma', norm=mpl.colors.LogNorm(vmin=0.01, vmax=100)) fig.colorbar(pc, ax=axs[1, 0], extend='both') axs[1, 0].set_title('imshow() with LogNorm()') pc = axs[1, 1].scatter(data1, data2, c=data3, cmap='RdBu_r') fig.colorbar(pc, ax=axs[1, 1], extend='both') axs[1, 1].set_title('scatter()') plt.show() e10() 11. 多 axes 使用 dict 操作pythondef e11(): fig, axd = plt.subplot_mosaic([['upleft', 'right'], ['lowleft', 'right']], layout='constrained') axd['upleft'].set_title('upleft') axd['lowleft'].set_title('lowleft') axd['right'].set_title('right') e11()","tags":[{"name":"豆知识","slug":"豆知识","permalink":"https://vitsumoc.github.io/tags/%E8%B1%86%E7%9F%A5%E8%AF%86/"},{"name":"笔记","slug":"笔记","permalink":"https://vitsumoc.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"python","permalink":"https://vitsumoc.github.io/tags/python/"},{"name":"库","slug":"库","permalink":"https://vitsumoc.github.io/tags/%E5%BA%93/"}]},{"title":"Numpy入门笔记","date":"2023-11-28T01:13:53.000Z","path":"2023/11/28/pythonNumpy.html","text":"前言网站 https://numpy.org/ NumPy（Numerical Python）是Python中数字处理的事实标准，也是学习其他数据知识的必备工具。 本文是学习Numpy过程中的笔记，所有内容都来自官方文档：https://numpy.org/doc/stable/user/absolute_beginners.html 1. 普通数组和np数组的区别pythonimport numpy as np # 普通数组 a = [0, 1, 2, 3] print(a) # np数组 b = np.array(a) print(b) 2. 创建np数组的方法pythonnp.zeros(2) # 全0填充 np.ones(2) # 全1填充 np.empty(2) # 空数组 np.arange(4) # [0, 1, 2, 3] np.arange(2, 9, 2) # [2, 4, 6, 8] np.linspace(0, 10, num=5) # [0, 2.5, 5, 7.5, 10] # 可以自己决定数据类型 np.ones(2, dtype=np.int64) # [1, 1] 3. 排序和拼接pythonarr = np.array([2, 1, 5, 3, 7, 4, 6, 8]) np.sort(arr) # 排序 a = np.array([1, 2, 3, 4]) b = np.array([5, 6, 7, 8]) np.concatenate((a, b)) # 拼接 x = np.array([[1, 2], [3, 4]]) y = np.array([[5, 6]]) np.concatenate((x, y), axis=0) # 拼接 4. 形状和大小pythonarray_example = np.array([ [[0, 1, 2, 3], [4, 5, 6, 7]], [[0, 1, 2, 3], [4, 5, 6, 7]], [[0 ,1 ,2, 3], [4, 5, 6, 7]] ]) array_example.ndim # 维度 3 array_example.size # 大小 24 array_example.shape # 形状 (3, 2, 4) 5. 改变数组的形状pythona = np.arange(6) b = a.reshape(3, 2) # [[0 1] # [2 3] # [4 5]] np.reshape(a, newshape=(1, 6), order='C') # 更多参数 6. 添加维度pythona = np.array([1, 2, 3, 4, 5, 6]) a.shape # 一维 (6, ) a2 = a[np.newaxis, :] a2.shape # 二维 (1, 6) col_vector = a[:, np.newaxis] # 插入列向量 col_vector.shape # 二维 (6, 1) # 在指定维度插入 b = np.expand_dims(a, axis=1) b.shape # (6, 1) c = np.expand_dims(a, axis=0) c.shape # (1, 6) 7. 索引和切片pythondata = np.array([1, 2, 3]) data[1] # 正常索引方式 2 data[0:2] # 正常切片 array([1, 2]) data[1:] # 正向到底 array([2, 3]) data[-2:] # 反向到底 array([2, 3]) # 条件过滤 a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) a[a &lt; 8] # 符合条件的内容 [1 2 3 4 5 6 7] five_up = (a >= 5) # 条件表达式作为参数 a[five_up] # [5 6 7 8 9 10 11 12] c = a[(a > 2) &amp; (a &lt; 11)] # 可以使用与&amp;或| [3 4 5 6 7 8 9 10] five_up = (a > 5) | (a == 5) # 条件本身会被计算成一个bool数组, 和原数组结构相同 five_up # [[False False False False] # [ True True True True] # [ True True True True]] a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) b = np.nonzero(a &lt; 6) # 根据查询条件, 返回符合条件的元素的索引 # 返回的数组数是a的维数, 返回值是索引值, 返回长度是符合条件的个数 # print(b) # (array([0, 0, 0, 0, 1], dtype=int64), array([0, 1, 2, 3, 0], dtype=int64)) # 将上述内容压缩成坐标列表 list_of_coordinates= list(zip(b[0], b[1])) # [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0]] a[b] # 也可以用索引直接获得元素 [1 2 3 4 5] # 结果为空 not_there = np.nonzero(a == 42) # (array([], dtype=int64), array([], dtype=int64)) 8. 现有数据转数组pythona = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) arr1 = a[3:8] # 通过切片创建新数组 array([4, 5, 6, 7, 8]) a1 = np.array([[1, 1], [2, 2]]) a2 = np.array([[3, 3], [4, 4]]) np.vstack((a1, a2)) # 垂直堆叠 [[1, 1], [2, 2], [3, 3], [4, 4]] np.hstack((a1, a2)) # 水平堆叠 [[1, 1], [3, 3], [2, 2], [4, 4]] x = np.arange(1, 25).reshape(2, 12) # 素材 # array([[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], # [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]]) np.hsplit(x, 3) # 拆成三个 # [array([[ 1, 2, 3, 4], # [13, 14, 15, 16]]), array([[ 5, 6, 7, 8], # [17, 18, 19, 20]]), array([[ 9, 10, 11, 12], # [21, 22, 23, 24]])] np.hsplit(x, (3, 4)) # 按指定列号拆分 # [array([[ 1, 2, 3], # [13, 14, 15]]), array([[ 4], # [16]]), array([[ 5, 6, 7, 8, 9, 10, 11, 12], # [17, 18, 19, 20, 21, 22, 23, 24]])] # 视图是引用, 修改视图也会修改原数据 a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) b1 = a[0, :] # array([1, 2, 3, 4]) b1[0] = 99 a # array([[99, 2, 3, 4], # [ 5, 6, 7, 8], # [ 9, 10, 11, 12]]) # copy是复制, 修改copy对原数据没影响 b2 = a.copy() 9. 基础数组操作python# 加减乘除 data = np.array([1, 2]) # [1 2] ones = np.ones(2, dtype=int) # [1 1] data + ones # [2 3] # 求和 a = np.array([1, 2, 3, 4]) a.sum() # 10 # 在所选维度求和 b = np.array([[1, 1], [2, 2]]) b.sum(axis=0) # [3, 3] b.sum(axis=1) # [2, 4] # 和常量的运算 data = np.array([1.0, 2.0]) data * 1.6 # [1.6 3.2] # 素材 a = np.array([[0.45053314, 0.17296777, 0.34376245, 0.5510652], [0.54627315, 0.05093587, 0.40067661, 0.55645993], [0.12697628, 0.82485143, 0.26590556, 0.56917101]]) a.sum() # 求和 4.8595784 a.min() # 极小值 0.05093587 a.min(axis=0) # 维度极小值 [0.12697628, 0.05093587, 0.26590556, 0.5510652 ] 10. 矩阵pythondata = np.array([[1, 2], [3, 4], [5, 6]]) # array([[1, 2], # [3, 4], # [5, 6]]) data[0, 1] # 正常索引 2 data[1:3] # 正常切片 array([[3, 4], [5, 6]]) data[0:2, 0] # 0:2是切片, 0是索引, 切片和索引混用 array([1, 3]) data.max() # 6 data.min() # 1 data.sum() # 21 # 也可以指定维度 data = np.array([[1, 2], [5, 3], [4, 6]]) data.max(axis=0) # array([5, 6]) data.max(axis=1) # array([2, 5, 6]) # 矩阵之间的运算（需要矩阵尺寸相同） data = np.array([[1, 2], [3, 4]]) ones = np.array([[1, 1], [1, 1]]) data + ones # array([[2, 3], [4, 5]]) # 如果某个矩阵只有一行或者一列, 也可使用广播规则运算 data = np.array([[1, 2], [3, 4], [5, 6]]) ones_row = np.array([[1, 1]]) data + ones_row # array([[2, 3], # [4, 5], # [6, 7]]) 11. 生成随机数pythonrng = np.random.default_rng() rng.integers(5, size=(2, 4)) # 两行四列, 随机整数, 小于5 rng.random((3, 2)) # 三行两列 0-1之间 float 12. 去重和计数pythona = np.array([11, 11, 12, 13, 14, 15, 16, 17, 12, 13, 11, 14, 18, 19, 20]) unique_values = np.unique(a) # 去重 [11 12 13 14 15 16 17 18 19 20] unique_values, indices_list = np.unique(a, return_index=True) # 序号 [ 0 2 3 4 5 6 7 12 13 14] unique_values, occurrence_count = np.unique(a, return_counts=True) # 数量 [3 2 2 2 1 1 1 1 1 1] # 对多维数组也可用 a_2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [1, 2, 3, 4]]) unique_values = np.unique(a_2d) # 去重 [ 1 2 3 4 5 6 7 8 9 10 11 12] unique_rows = np.unique(a_2d, axis=0) # 获得去重的行 # [[ 1 2 3 4] # [ 5 6 7 8] # [ 9 10 11 12]] unique_rows, indices, occurrence_count = np.unique(a_2d, axis=0, return_counts=True, return_index=True) indices # 所得行的序号 [0 1 2] occurrence_count # 所得行的数量 [2 1 1] 13. 矩阵转置和变形pythondata = np.array([1, 2, 3, 4, 5, 6]) # 变形 data.reshape(2, 3) # array([[1, 2, 3], # [4, 5, 6]]) data.reshape(3, 2) # array([[1, 2], # [3, 4], # [5, 6]]) # 转置 data = data.reshape(2, 3) # 先准备一个 23 矩阵 # array([[1, 2, 3], # [4, 5, 6]]) data.transpose() # 转置 # [[1 4] # [2 5] # [3 6]] # 也可以直接用T data.T # [[1 4] # [2 5] # [3 6]] 14. 数组逆序pythonarr = np.array([1, 2, 3, 4, 5, 6, 7, 8]) reversed_arr = np.flip(arr) # [8 7 6 5 4 3 2 1] # 二维数组逆序 arr_2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) reversed_arr = np.flip(arr_2d) # [[12 11 10 9] # [ 8 7 6 5] # [ 4 3 2 1]] # 针对的维度逆序 reversed_arr_rows = np.flip(arr_2d, axis=0) # [[ 9 10 11 12] # [ 5 6 7 8] # [ 1 2 3 4]] # 对切片逆序并赋值 arr_2d[:,1] = np.flip(arr_2d[:,1]) # [[ 1 10 3 4] # [ 8 7 6 5] # [ 9 2 11 12]] 15. 多维数组展开pythonx = np.array([[1 , 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) x.flatten() # 拷贝展开 array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) a2 = x.ravel() # 引用展开 array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) 16. 内置文档python# help(max) 输出说明 # max? 同名所有函数说明 a = np.array([1, 2, 3, 4, 5, 6]) # a? 变量说明 17. 实现数学公式pythonpredictions = np.array([1, 2, 3]) labels = np.array([1, 1, 1]) # 例如均方误差公式 error = (1 / 3) * np.sum(np.square(predictions - labels)) 18. np对象导入导出pythona = np.array([1, 2, 3, 4, 5, 6]) # np.save('filename', a) 存成文件 # b = np.load('filename.npy') 从文件读取 # 使用csv格式 # np.savetxt('new_file.csv', a) # np.loadtxt('new_file.csv') 19. 使用 Pandas 库进行csv导入导出操作pythonimport pandas as pd # # If all of your columns are the same type: # x = pd.read_csv('music.csv', header=0).values # print(x) # [['Billie Holiday' 'Jazz' 1300000 27000000] # ['Jimmie Hendrix' 'Rock' 2700000 70000000] # ['Miles Davis' 'Jazz' 1500000 48000000] # ['SIA' 'Pop' 2000000 74000000]] # # You can also simply select the columns you need: # x = pd.read_csv('music.csv', usecols=['Artist', 'Plays']).values # print(x) # [['Billie Holiday' 27000000] # ['Jimmie Hendrix' 70000000] # ['Miles Davis' 48000000] # ['SIA' 74000000]] 20. 使用 Matplotlib 绘制数据图像pythonimport matplotlib.pyplot as plt # 显示数组 a = np.array([2, 1, 5, 7, 4, 6, 8, 14, 10, 9, 18, 20, 22]) plt.plot(a) plt.show() # 两种数据 x = np.linspace(0, 5, 20) y = np.linspace(0, 10, 20) plt.plot(x, y, 'purple') # line plt.plot(x, y, 'o') # dots plt.show() # 高级使用 fig = plt.figure() ax = fig.add_subplot(projection='3d') X = np.arange(-5, 5, 0.15) Y = np.arange(-5, 5, 0.15) X, Y = np.meshgrid(X, Y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R) ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='viridis') plt.show()","tags":[{"name":"豆知识","slug":"豆知识","permalink":"https://vitsumoc.github.io/tags/%E8%B1%86%E7%9F%A5%E8%AF%86/"},{"name":"笔记","slug":"笔记","permalink":"https://vitsumoc.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"python","permalink":"https://vitsumoc.github.io/tags/python/"},{"name":"库","slug":"库","permalink":"https://vitsumoc.github.io/tags/%E5%BA%93/"}]},{"title":"AI入门笔记（2）——知识表示与专家系统","date":"2023-11-24T07:33:38.000Z","path":"2023/11/24/AiForBeginners-2.html","text":"课程https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/README.md 这是微软提供的AI-For-Beginners课程第二课，介绍了过去常见的自顶向下的AI设计方法。 内容通过DIKW金字塔，探讨了 数据、信息、知识、智慧 的含义，传统的人工智能实现方式就是一类尝试将数据组织成知识的方法。 探讨了使用计算机表达知识的几种方式。 专家系统介绍了早期symbolic AI的一种成功实践：专家系统。 将专家系统的实现区分为两种类型：向后推理与向前推理。 后向推理实现专家系统的代码实践：https://github.com/vitsumoc/exercise-AI-Beginner/blob/main/2-Symbolic/animal_Inference.py 本体论和语义网ontology 本体指的是某个概念实体，Semantic Web 语义网指的是对本体的各种规范性描述的集合，简单的有对本体属性的描述，复杂的有对各种逻辑关系的描述。 本体和语义网也是对人类思考方式的归纳和模仿，是一种组织复杂数据形成知识的方式，WikiData 就是这样的一个知识库。 使用语义网实现家谱查询系统的代码实践：https://github.com/vitsumoc/exercise-AI-Beginner/blob/main/2-Symbolic/family_ontology.py 总结学习了Symbolic AI的概念，历史，还通过几个简单例子进行了最简单的了解。 可以感受到曾经计算机行业的先驱者们为了赋予计算机智能，付出了多少辛劳和汗水，也取得了巨大的成果。 However, the important characteristics of knowledge-based systems is that you can always explain exactly how any of the decisions were made.","tags":[{"name":"AI","slug":"AI","permalink":"https://vitsumoc.github.io/tags/AI/"},{"name":"笔记","slug":"笔记","permalink":"https://vitsumoc.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"AI入门笔记（1）——简介与历史","date":"2023-11-24T01:42:38.000Z","path":"2023/11/24/AiForBeginners-1.html","text":"课程https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/1-Intro/README.md 这是微软提供的AI-For-Beginners课程第一课，对AI的基础概念、定义、发展历史等内容进行了简单的介绍。 内容什么是Weak AI，什么是Strong AI 什么是图灵测试，如何定义Intelligence AI的不同实现路径，过去主要是Symbolic Reasoning，而现在主要使用Neural Networks AI发展的简要历史 近年来AI技术取得的重大进展：图片识别、自然语言识别、翻译等等","tags":[{"name":"AI","slug":"AI","permalink":"https://vitsumoc.github.io/tags/AI/"},{"name":"笔记","slug":"笔记","permalink":"https://vitsumoc.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"使用SSH包装Socks5代理","date":"2023-11-22T09:38:25.000Z","path":"2023/11/22/SSHInSubSocks.html","text":"subSocks简介subSocks是Luyu Huang制作的纯golang网络代理软件。 这里是作者本人对此项目的介绍文档。 为什么要做SSH包装因为之前使用v2ray总是被封端口，但是VPS上的22端口始终建在，考虑到SSH协议比较复杂，包括了Shell，SFTP等多种应用。我认为使用SSH协议包装流量可以起到一定的伪装作用，减少端口被封的可能性。 subSocks项目的代码结构非常漂亮，添加SSH包装非常便捷。 实现过程首先需要了解subSocks的代码结构，Luyu Huang的文档中描述的非常详细，我只需要实现SSHWarpper和SSHStripper。 golang已经提供了SSH的官方实现，参考文档。并且提供了使用SSH进行远程Shell的示例。 之后需要对SSH的通讯过程，Session Channel Request等等各种概念有基础的了解。 使用ssh包中的代码，在服务端使用TCP链接，创建SSH服务器，等待客户端链接后获取Channel，将Channel包装为Stripper。 客户端与服务端相似，需要使用TCP链接，向服务端完成握手过程，之后可获得Session，将Session包装成Wrapper。 使用服务端必须配置密钥，可使用自己生成的密钥： toml1234567[server] # server configurationprotocol = &quot;ssh&quot;listen = &quot;0.0.0.0:22&quot;ssh.cert = &quot;./id_rsa.pub&quot;ssh.key = &quot;./id_rsa&quot; 客户端只需将协议设置为ssh，其他与subsocks相同: toml123456[client] # client configurationlisten = &quot;127.0.0.1:1080&quot;server.protocol = &quot;ssh&quot;server.address = &quot;serverIP:22&quot; 通过抓包验证，握手过程正常，通讯过程与SSH相同，多条链接使用正常，所有数据均经过加密： 通过观看视频网站验证，视频加载流畅，体验很好。","tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://vitsumoc.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"SSH","slug":"SSH","permalink":"https://vitsumoc.github.io/tags/SSH/"}]},{"title":"golang与串口设备在项目中的运用","date":"2023-11-22T03:06:28.000Z","path":"2023/11/22/golangSerial.html","text":"需求简述硬件设备使用485Modbus通讯，需使用golang编写采集程序，将数据采集至平台。 方案简述使用串口服务器将485Modbus通讯转为TCPModbus，并将串口服务器设置为TCPserver。 使用golang编写采集器，定期向串口服务器建立TCP链接，采集数据。 技术点与实现点表通过struct实现点位表 这里使用Raw表示原始点表数据，和通讯协议一一对应 后续可将Raw结构封装至更高层的业务结构，用来实现业务数据的表示、嵌套能其他功能 gotype StructMcuRaw struct &#123; Ver [4]uint8 `json:\"ver\"` // 软件版本[4]char Id uint16 `json:\"id\"` // 通信箱id TargetAngle uint16 `json:\"targetAngle\" IEC104:\"yc\" IEC104Name:\"子阵目标角度\" IEC104Unit:\"°\" IEC104Factor:\"0.1\"` // 对整个子阵设置目标角度 InitSnowDepth uint16 `json:\"initSnowDepth\" IEC104:\"yx\" IEC104Name:\"标定初始雪深标志\"` // 标定初始雪深标志 PrecipitationType uint16 `json:\"precipitationType\"` // 降水类型 &#125; 读取二进制数据通过binary包，可以实现从buffer中读取数据向struct赋值 gofunc (p *StructMcuRaw) MCUFromByte(res *bytes.Buffer) &#123; // 软件版本[4]char for x := 0; x &lt; 4; x++ &#123; binary.Read(res, binary.BigEndian, p.Ver[x]) &#125; // 通信箱id binary.Read(res, binary.BigEndian, &amp;p.Id) // 对整个子阵设置目标角度 binary.Read(res, binary.BigEndian, &amp;p.TargetAngle) // 标定初始雪深标志 binary.Read(res, binary.BigEndian, &amp;p.InitSnowDepth) // 降水类型 binary.Read(res, binary.BigEndian, &amp;p.PrecipitationType) &#125; 封装为query在本项目中，query指对单个设备的采集方法 将数据读取封装成query方法，包括TCP采集过程、日志记录、包格式处理等 gofunc MCUQuery(conn *net.Conn, reader *bufio.Reader, buffer *[]byte, cb *rs.StructCommBox, mcu *rs.StructMcu) error &#123; // 查询地址 addInt, err := strconv.Atoi(mcu.Addr) if err != nil &#123; return err &#125; // 包编号 tcpSeq := TcpSeq() var query = []byte&#123; uint8(tcpSeq / 0x100), uint8(tcpSeq % 0x100), // 编号 0x00, 0x00, 0x00, 0x06, // 长度 byte(addInt), 0x03, 0x00, 0xa0, 0x00, 0x29&#125; // 指令 (*conn).SetWriteDeadline(time.Now().Add(rs.QUERY_DEFAULT_TIMEOUT)) _, err = (*conn).Write(query) if err != nil &#123; log.Log(true, cb.IpAddr, cb.Port, []byte&#123;&#125;) return err &#125; // 日志 log.Log(true, cb.IpAddr, cb.Port, query) // 接收 (*conn).SetReadDeadline(time.Now().Add(rs.QUERY_DEFAULT_TIMEOUT)) n, err := (*reader).Read(*buffer) if err != nil &#123; log.Log(false, cb.IpAddr, cb.Port, []byte&#123;&#125;) return err &#125; // 日志 log.Log(false, cb.IpAddr, cb.Port, (*buffer)[:n]) // 解析 res := bytes.NewBuffer(*buffer) // TCP头 var tcpHeader rs.StructTCPHeader tcpHeader.TCPHeaderFromByte(res) if tcpHeader.Seq != tcpSeq &#123; return errors.New(\"TCP异常\") &#125; if tcpHeader.Len != 85 &#123; return errors.New(\"TCP长度异常\") &#125; // modbus头 var mbHeader rs.StructMudbusHeader mbHeader.MudbusHeaderFromByte(res) // mcu内容 mcu.Raw.MCUFromByte(res) mcu.VUpdate = true // 标记更新 return nil &#125; 封装为采集过程最后需要将所有的采集query放置在统一的采集过程中 在一次采集过程中，创建一条TCP链接，完成所有采集动作，最后断开链接 gofunc Collect(cb *rs.StructCommBox) &#123; // 记录网络占用 NetCh &lt;- true defer func() &#123; &lt;-NetCh &#125;() // 初始化采集标识 eraseFlag(cb) // 采集结束后更新时标 defer func() &#123; updateTs(cb) &#125;() // 建链 conn, err := net.DialTimeout(\"tcp\", cb.IpAddr+\":\"+cb.Port, rs.QUERY_DEFAULT_TIMEOUT) if err != nil &#123; log.Log(true, cb.IpAddr, cb.Port, []byte&#123;&#125;) return &#125; cb.VUpdate = true defer conn.Close() // 读写缓存 readBuf := bufio.NewReader(conn) buffer := make([]byte, 256) // 按mcu查询 for x := 0; x &lt; len(cb.Mcus); x++ &#123; // 切换MCU预留时间, 提高成功率 time.Sleep(rs.QUERY_MCU_INTERVAL) // 查mcu信息 mcu := cb.Mcus[x] err = cmd.MCUQuery(&amp;conn, readBuf, &amp;buffer, cb, mcu) if err != nil &#123; return &#125; // 分次查跟踪器信息 for y := 0; y &lt; mcu.TracerNum; &#123; // 切换Tracer预留时间, 提高成功率 time.Sleep(rs.QUERY_TRACER_INTERVAL) // 查询长度 tracerLen := rs.QUERY_TRACER_COUNT if mcu.TracerNum-y &lt; rs.QUERY_TRACER_COUNT &#123; tracerLen = mcu.TracerNum - y &#125; err = cmd.TracerQuery(&amp;conn, readBuf, &amp;buffer, cb, mcu, y, tracerLen) if err != nil &#123; return &#125; y += tracerLen &#125; &#125; &#125; 总结使用golang+串口服务器进行串口通讯，非常的简单、直观，易于开发维护。 在本次项目实践中，由于golang提供了方便的并发编程与控制机制，高负载环境下的性能也得到了充分保障。","tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://vitsumoc.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"项目实践","slug":"项目实践","permalink":"https://vitsumoc.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"},{"name":"golang","slug":"golang","permalink":"https://vitsumoc.github.io/tags/golang/"},{"name":"串口通讯","slug":"串口通讯","permalink":"https://vitsumoc.github.io/tags/%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/"}]},{"title":"SSH握手过程","date":"2023-11-20T01:20:06.000Z","path":"2023/11/20/SSH.html","text":"RFChttps://datatracker.ietf.org/doc/html/rfc4253 SSH简介安全外壳协议（Secure Shell Protocol，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中建立安全隧道来实现SSH客户端与服务器之间的连接。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。 SSH数据包基本格式SSH的数据包加密后分块传输，每次传输的实际包长度都应为密码块大小的整数倍或8 每个加密后的数据包都由如下结构构成 c12345uint32 packet_length;byte padding_length;byte[n1] payload; // n1 = packet_length - padding_length - 1byte[n2] random_padding; // n2 = padding_lengthbyte[m] mac(Message_Authentication_Code - MAC); // m = mac_length packet_length：数据载荷的长度，不包括mac部分和packet_length本身。在进行加密协商完成后，传输的packet_length也会被加密 padding_length：random_padding块的大小 payload：数据载荷，根绝协商决定被加密或被压缩的方法 random padding： 0-255位随机填充 mac：信息认证码，用作信息完整性校验 SSH过程以下采用一个SSH抓包结果为例，描述SSH链接建立过程： |&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;| |&nbsp;&nbsp;&nbsp;客户端&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;服务端&nbsp;&nbsp;&nbsp;&nbsp;| |&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;| |&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;链接建立&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;| |1. 三次握手1|—————————————————————————————–&gt; &lt;—————————————————————————————-|2. 三次握手2| |3. 三次握手3|—————————————————————————————–&gt; |&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;协议协商&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;| &lt;—————————————————————————————-|4. 服务端协议| |5. 客户端协议|—————————————————————————————–&gt; |&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;算法协商&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;| &lt;————————————————————————————-|6. 服务端算法表| |7. 客户端算法表|————————————————————————————&gt; |&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;密钥交换&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;| |8. Diffie-Hellman Init|——————————————————————————&gt; &lt;————————————————|9. Diffie-Hellman Reply，New Keys，加密包| |10. New Keys|—————————————————————————————-&gt; |&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;加密通讯&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;| 链接建立（1）（2）（3）三次握手报文 TCP三次握手 协议协商（4）服务端协议报文 Hex内容 0x 53 53 48 2d 32 2e 30 2d 4f 70 65 6e 53 53 48 5f 38 2e 30 0d 0a 报文内容 SSH-2.0-OpenSSH_8.0&lt;CR&gt;&lt;LF&gt; 包括SSH、协议版本（2.0）、软件版本（OpenSSH_8.0） （5）客户端协议报文 Hex内容 0x 53 53 48 2d 32 2e 30 2d 6e 73 73 73 68 32 5f 37 2e 30 2e 30 30 33 33 20 4e 65 74 53 61 72 61 6e 67 20 43 6f 6d 70 75 74 65 72 2c 20 49 6e 63 2e 0d 0a 报文内容 SSH-2.0-nsssh2_7.0.0033 NetSarang Computer, Inc.&lt;CR&gt;&lt;LF&gt; 算法协商在算法协商的过程中，双方会各自发送自己支持的算法列表，最终对以下几个算法达成共识： kex_algorithms：密钥交换算法 server_host_key_algorithms：公钥算法 encryption_algorithms：加密算法 mac_algorithms：数据完整性算法 compression_algorithms：压缩算法 languages：语言标签（可选） first_kex_packet_follows：表示是否有猜测数据包 在达成共识的过程中，基本以客户端中的算法排序优先匹配 （6）服务端算法表报文 packet_length：0x00 00 04 14（1044） padding_length：0x05（5） SSH_MSG_SERVICE_ACCEPT：0x14（SSH_MSG_KEXINIT） Cookie：0xd7 86 29 66…(16Byte) kex_algorithms length：下方算法表长度 kex_algorithms list：算法表（字符串表示，逗号分隔） server_host_key_algorithms length：下方算法表长度 server_host_key_algorithms list：算法表（字符串表示，逗号分隔） encryption_algorithms_client_to_server length：下方算法表长度 encryption_algorithms_client_to_server list：算法表（字符串表示，逗号分隔） encryption_algorithms_server_to_client length：下方算法表长度 encryption_algorithms_server_to_client list：算法表（字符串表示，逗号分隔） mac_algorithms_client_to_server length：下方算法表长度 mac_algorithms_client_to_server list：算法表（字符串表示，逗号分隔） mac_algorithms_server_to_client length：下方算法表长度 mac_algorithms_server_to_client list：算法表（字符串表示，逗号分隔） compression_algorithms_client_to_server length：下方算法表长度 compression_algorithms_client_to_server list：算法表（字符串表示，逗号分隔） compression_algorithms_server_to_client length：下方算法表长度 compression_algorithms_server_to_client list：算法表（字符串表示，逗号分隔） languages_client_to_server length：下方算法表长度 languages_client_to_server list：算法表（字符串表示，逗号分隔） languages_server_to_client length：下方算法表长度 languages_server_to_client list：算法表（字符串表示，逗号分隔） first_kex_packet_follows：0x00 Reserved：0x00 00 00 00 Padding：0x00 00 00 00 00（padding_length长度） （7）客户端算法表报文 与服务端算法表格式相同 密钥交换通过双方协商，决定采用Elliptic Curve Diffie-Hellman方式进行密钥交换 （8）客户端Diffie-Hellman Init packet_length：0x00 00 00 2c padding_length：0x06 MSG：0x1e（Elliptic Curve Diffie-Hellman Key Exchange Init） 客户端公钥长度：0x00 00 00 20（32） 客户端公钥：0xd1 d9 b8 6c 84 67 55 0f ca 84 6e 8b 0e 67 25 27 6b 50 ae ed a4 6d dc 0b 73 4c 15 ad e9 f5 51 66 Padding：0x91 f0 e8 0c f4 9b （9）服务端Diffie-Hellman Reply，New Keys，加密包 服务端的回复包含三部分内容，Key Exchange Reply、New Keys、 加密包 其中，Key Exchange Reply包括了密钥交换的结果 packet_length：0x00 00 03 5c padding_length：0x08 MSG：0x1f（Elliptic Curve Diffie-Hellman Key Exchange Reply） Host Key Length：0x00 00 01 97 Host Key Type Length：0x00 00 00 07 Host Key Type：0x73 73 68 2d 72 73 21（ssh-rsa） Multi Precision Integer Length：0x00 00 00 03 RSA public exponent (e)：0x01 00 01 Multi Precision Integer Length：0x00 00 01 81 RSA Modulus (N)：0x00 be 1b 4b 73 9d f8 37 0e 33… ECDH server’s ephemeral public key length：0x00 00 00 20 ECDH server’s ephemeral public key (Q_S)：0x3a 2e 62 f6 ee… KEX H signature length：0x00 00 01 8f KEX H signature ：0x00 00 00 07 73 73 68 2d 72 73 61 00 00 01 80 a0… Padding：0x00 00 00 00 00 00 00 00 New Keys表示密钥交换完成，此后的内容都需要使用新密钥处理 packet_length：0x00 00 00 0c padding_length：0x0a MSG：0x15（SSH_MSG_NEWKEYS） Padding：0x00 00 00 00 00 00 00 00 00 00 后续的数据已经被加密，无法查看内容，推测是与客户端进行登录认证的协商 （10）客户端New Keys 客户端的New Keys包与服务端相同，后续客户端发送数据也都被加密处理","tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://vitsumoc.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"SSH","slug":"SSH","permalink":"https://vitsumoc.github.io/tags/SSH/"}]},{"title":"在Windows中使用Linux——WSL","date":"2023-11-17T08:36:34.000Z","path":"2023/11/17/WSL.html","text":"https://learn.microsoft.com/zh-cn/windows/wsl/","tags":[{"name":"豆知识","slug":"豆知识","permalink":"https://vitsumoc.github.io/tags/%E8%B1%86%E7%9F%A5%E8%AF%86/"},{"name":"环境配置","slug":"环境配置","permalink":"https://vitsumoc.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Linux","slug":"Linux","permalink":"https://vitsumoc.github.io/tags/Linux/"}]}]